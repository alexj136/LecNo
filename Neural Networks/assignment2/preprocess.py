from instances import Instance
from copy      import deepcopy
from misc      import meanInst

class Preprocessor:
    '''A preprocessor object is generated by the preprocess() function, so that
    subsequent preprocessing can be performed by calling preprocessWith(), with
    the generated Preprocessor object as the second parameter. This will ensure
    that the mappings applied to the instances preprocessed with
    preprocessWith() are identical to those used to preprocess the instances
    initially preprocessed with preprocess().'''
    def __init__(self, meanInst, scaleInst):
        self.meanInst  = meanInst
        self.scaleInst = scaleInst

def preprocess(insts):
    '''Preprocess a list of Instances, returning a Preprocessor object that can
    be used to preprocess more instances with the same mapping.'''
    demeanedInsts, meanInst = demean(insts)
    scaledInsts, scaleInst = scale(demeanedInsts)
    return scaledInsts, Preprocessor(meanInst, scaleInst)

def preprocessWith(insts, preproc):
    '''Preprocess a list of instances according to the mapping described by the
    given Preprocessor object.'''
    demeanedInsts = [demeanNewInst(inst, preproc.meanInst) for inst in insts]
    return [scaleNewInst(inst, preproc.scaleInst) for inst in demeanedInsts]

def demean(insts):
    '''Produce a new list of instances from the given ones, that have been
    demeaned. Return a new list, and an Instance object that represents the mean
    values of the data from the original instances, that can be used to demean
    unseen instances, or to recover values in the original domain'''

    meanI = meanInst(insts)

    # Create new instances from the old ones and adjust all values appropriately
    newInsts = deepcopy(insts)
    for inst in newInsts:
        for d in range(len(inst.data)):
            inst.data[d] = inst.data[d] - meanI.data[d]
        for l in range(len(inst.label)):
            inst.label[l] = inst.label[l] - meanI.label[l]
    
    return newInsts, meanI

def demeanNewInst(inst, means):
    '''Given an unseen Instance and an example mean Instance, return a new
    instance in the same domain as the data that produced the example
    Instance'''
    newInst = deepcopy(inst)
    for feat in range(len(newInst.data)):
        newInst.data[feat] = newInst.data[feat] - means.data[feat]
    for lbl in range(len(newInst.label)):
        newInst.label[lbl] = newInst.label[lbl] - means.label[lbl]
    return newInst

def scale(insts):
    '''Produce a list of Instances that are scaled versions of the given
    Instances. Return the new instances and an example Instance that stores the
    scale factors for each dimension of the given instances.'''

    # We record the scale factor for feature and return them in a list, so
    # that we can (a) apply an identical transformation to unseen instances and
    # (b) recover the feature values as they were before scaling
    featScales = []

    for feat in range(len(insts[0].data)):

        # Find the maximum value for this feature, which we will use as our
        # scale factor
        absMax = 0
        for inst in insts:
            if abs(inst.data[feat]) > absMax:
                absMax = abs(inst.data[feat])

        # Record this scale factor
        featScales.append(absMax)

    labelScales = []    

    for lbl in range(len(insts[0].label)):

        # Find the maximum value for this target dimension, which we will use as
        # our scale factor
        absMax = 0
        for inst in insts:
            if abs(inst.label[lbl]) > absMax:
                absMax = abs(inst.label[lbl])

        # Record this scale factor
        labelScales.append(absMax)

    # Create new instances from the old ones and adjust all values appropriately
    newInsts = deepcopy(insts)
    for inst in newInsts:
        for d in range(len(inst.data)):
            inst.data[d] = inst.data[d] / featScales[d]
        for l in range(len(inst.label)):
            inst.label[l] = inst.label[l] / labelScales[l]

    return newInsts, Instance(featScales, labelScales)

def scaleNewInst(inst, scaleFacs):
    '''Given an instance and a scale factor example Instance, for data returned
    by scale(), return a new instance that is equivalent to the given instance,
    but in the scaled domain.'''
    newInst = deepcopy(inst)
    for feat in range(len(newInst.data)):
        newInst.data[feat] = newInst.data[feat] / scaleFacs.data[feat]
    for lbl in range(len(newInst.label)):
        newInst.label[lbl] = newInst.label[lbl] / scaleFacs.label[lbl]
    return newInst
