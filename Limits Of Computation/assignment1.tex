\documentclass{article}
\usepackage{amsmath}

\title{Limits Of Computation: Assignment 1}
\author{Candidate Number: 18512}

\begin{document}
\maketitle

\section*{Question 1}
Answers to this question are given in WIDE list syntax.
\begin{enumerate}
    \item[\textbf{(a)}] \texttt{((nil.nil).(nil.nil))} \\
        This can be interpreted as a list of numbers - it is the list \texttt{(1 0)}
    \item[\textbf{(b)}] \texttt{((nil.nil).(nil.(nil.nil)))} \\
        This can also be interpreted as a list of numbers - it is the list \texttt{(1 0 0)}
    \item[\textbf{(c)}] \texttt{(nil.((nil.nil).(nil.(nil.nil))))} \\
        This can also be interpreted as a list of numbers - it is the list \texttt{(0 1 0 0)}
    \item[\textbf{(d)}] \texttt{((nil.(nil.nil)).(nil.(nil.nil)))} \\
        This can also be interpreted as a list of numbers - it is the list \texttt{(2 0 0)}
\end{enumerate}

\section*{Question 2}
The program:
\begin{verbatim}
    f(y) whererec f(y) = if y then cons nil f(tl y)
                              else nil
\end{verbatim}
\indent computes the length of a list. Every binary tree can be thought of as encoding a list, and we can show this by giving an informal definition of lists:
\begin{itemize}
    \item \texttt{nil} encodes the empty list
    \item \texttt{cons A B} encodes a list containing the element \texttt{A} concatenated with the list interpretation of \texttt{B}. Since \texttt{A} and \texttt{B} can be arbitrary trees, we can say that every binary tree encodes a list.
\end{itemize}
The given \texttt{F}-program builds a natural number encoding as it 'walks down' the spine of the given list. If the input is the empty list, \texttt{nil} i.e. \texttt{0} is returned. For all other inputs, which are of the form \texttt{cons A B}, the value returned is one plus the length of the list that B encodes.

\section*{Question 3}
The \texttt{F}-program \textbf{\texttt{diverge}} is given below:
\begin{verbatim}
    f(y) whererec f(y) = f(y)
\end{verbatim}
\textbf{INCOMPLETE}

\section*{Question 4}
The semantics of \texttt{if-then-else} in \texttt{F} are shown below:
\begin{equation*}
    \mathcal{F} [\![ \texttt{if} \hspace{1mm} E \hspace{1mm} \texttt{then} \hspace{1mm} F \hspace{1mm} \texttt{else} \hspace{1mm} G \hspace{1mm} ]\!] B \hspace{1mm} \texttt{d} = \begin{cases}
        \mathcal{F} [\![ G ]\!] B \hspace{1mm} \texttt{d} \hspace{3mm} \text{if} \hspace{3mm} \mathcal{F} [\![ E ]\!] B \hspace{1mm} \texttt{d} = \texttt{nil} \\
        \mathcal{F} [\![ F ]\!] B \hspace{1mm} \texttt{d} \hspace{3mm} \text{otherwise}
    \end{cases}
\end{equation*}

\section*{Question 5}
The data representation of the \texttt{F}-program \textbf{\texttt{limits}} is given below:
\begin{verbatim}
    (
        (appf (var))
    .
        (if
            (var)
            (cons (quote nil) (appf (tl (var))))
            (quote nil)
        )
    )
\end{verbatim}
Note that the outermost pair of brackets do not represent a list - they show that the stuff before the dot is constructed together with the stuff after it.

\section*{Question 6}
\begin{enumerate}
    \item[\textbf{(a)}] \texttt{WHILE}-programs are a good choice for a notion of effective computability because \texttt{WHILE} has a good balance of expressivity and simplicity. Expressivity is valuable when dealing with complex algorithms, such as those that handle programs as data objects, like compilers, interpreters and specialisers. Simplicity is valuable when proving properties of programs, which is something you would expect to do with a formalism for effective computability.
    \item[\textbf{(b)}] \texttt{F}-programs\dots
\end{enumerate}

\textbf{INCOMPLETE}

\section*{Question 7}
\texttt{Vl} is a stack that stores the values of variables. There is one variable in each function call, and so we have one variable on the stack for each function call that is made.
\end{document}
